/* Autogenerated file. Do not edit manually. */
// @ts-nocheck
/* tslint:disable */
/* eslint-disable */

import {
  CircuitZKit,
  CircuitZKitConfig,
  Groth16Proof,
  NumberLike,
  NumericString,
  PublicSignals,
} from "@solarity/zkit";

export type PrivateCheckKeyAndInclusion = {
  root: NumberLike;
  r: NumberLike[];
  s: NumberLike[];
  msgHash: NumberLike[];
  pk: NumberLike[][];
  proof: NumberLike[];
  path: NumberLike[];
};

export type PublicCheckKeyAndInclusion = {
  out: NumericString;
  root: NumericString;
  msgHash: NumericString[];
};

export type ProofCheckKeyAndInclusion = {
  proof: Groth16Proof;
  publicSignals: PublicCheckKeyAndInclusion;
};

export type Calldata = [
  [NumericString, NumericString],
  [[NumericString, NumericString], [NumericString, NumericString]],
  [NumericString, NumericString],
  [NumericString, NumericString, NumericString],
];

export class CheckKeyAndInclusion extends CircuitZKit {
  constructor(config: CircuitZKitConfig) {
    super(config);
  }

  public async generateProof(
    inputs: PrivateCheckKeyAndInclusion,
  ): Promise<ProofCheckKeyAndInclusion> {
    const proof = await super.generateProof(inputs as any);

    return {
      proof: proof.proof,
      publicSignals: this._normalizePublicSignals(proof.publicSignals),
    };
  }

  public async verifyProof(proof: ProofCheckKeyAndInclusion): Promise<boolean> {
    return await super.verifyProof({
      proof: proof.proof,
      publicSignals: this._denormalizePublicSignals(proof.publicSignals),
    });
  }

  public async generateCalldata(
    proof: ProofCheckKeyAndInclusion,
  ): Promise<Calldata> {
    return await super.generateCalldata({
      proof: proof.proof,
      publicSignals: this._denormalizePublicSignals(proof.publicSignals),
    });
  }

  public getSignalNames(): string[] {
    return ["out", "root", "msgHash"];
  }

  private _normalizePublicSignals(
    publicSignals: PublicSignals,
  ): PublicCheckKeyAndInclusion {
    const signalNames = this.getSignalNames();

    return signalNames.reduce((acc: any, signalName, index) => {
      acc[signalName] = publicSignals[index];
      return acc;
    }, {});
  }

  private _denormalizePublicSignals(
    publicSignals: PublicCheckKeyAndInclusion,
  ): PublicSignals {
    const signalNames = this.getSignalNames();

    return signalNames.map((signalName) => (publicSignals as any)[signalName]);
  }
}

export default CheckKeyAndInclusion;
